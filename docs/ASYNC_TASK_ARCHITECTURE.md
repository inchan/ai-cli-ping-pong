# 비동기 작업 실행 아키텍처 (Asynchronous Task Execution Architecture)

## 1. 문제 정의

기존의 `use_agent` 도구는 동기적으로(synchronously) 동작하여, AI CLI의 작업이 끝날 때까지 클라이언트의 요청을 차단(blocking)하는 문제가 있습니다. 이로 인해 수 분이 소요되는 긴 작업의 경우, 클라이언트는 응답이 올 때까지 아무것도 하지 못하고 기다려야 합니다.

이 문제를 해결하기 위해 '인터랙티브 타임아웃'(`elicit` 활용) 방식을 초기에 고려했으나, 클라이언트가 항상 인간 사용자라는 잘못된 전제에 기반하고 있어 AI 에이전트 등 자동화된 클라이언트와의 호환성 문제가 발생하는 치명적 설계 결함이 발견되었습니다.

따라서 모든 종류의 클라이언트를 안정적으로 지원할 수 있는 새로운 아키텍처가 필요합니다.

## 2. 해결 아키텍처: 비동기 작업 + 상태 폴링

업계 표준(de-facto standard)인 '비동기 작업 + 상태 폴링(Polling)' 모델을 채택합니다. 이 모델은 작업의 '요청'과 '결과 확인'을 명확히 분리하여 클라이언트의 블로킹을 없애고, 시스템의 견고성과 유연성을 극대화합니다.

특히, 단순한 폴링(Busy-Waiting)이 아닌 **Long-Polling**을 지원하여 불필요한 네트워크 요청과 토큰 소모를 최소화합니다.

**작동 흐름:**
1.  클라이언트는 `use_agent(run_async=true)`를 호출하여 긴 작업을 요청합니다.
2.  서버는 즉시 작업을 백그라운드에서 시작하고, 해당 작업을 추적할 수 있는 고유한 `task_id`를 클라이언트에게 즉시 반환합니다. (Time-To-Response 최소화)
3.  클라이언트는 받은 `task_id`를 사용하여, `get_task_status(timeout=30)`을 호출합니다.
4.  서버는 작업이 완료될 때까지 최대 30초간 응답을 보류(Hold)합니다.
5.  작업이 완료되면 즉시 결과를 반환하고, 아직 진행 중이면 30초 후 'running' 상태를 반환합니다.

## 3. 언제 비동기를 사용해야 하는가? (Guidelines)

모든 작업에 비동기가 필요한 것은 아닙니다. 작업의 예상 소요 시간과 클라이언트 환경을 고려하여 선택해야 합니다.

> **Note (Timeout):**
> *   **서버 타임아웃:** `other-agents-mcp` 서버의 기본 타임아웃은 **30분(1800초)**입니다. 즉, 서버는 작업이 30분까지 걸려도 연결을 유지하려 시도합니다.
> *   **클라이언트 타임아웃:** 하지만 Claude Desktop 등 MCP 클라이언트는 보통 **60초~5분** 정도 응답이 없으면 연결을 끊습니다.
> *   **결론:** 서버가 30분을 기다려줄 수 있어도, 클라이언트가 먼저 끊어버리므로 **5분 이상 걸리는 작업은 반드시 비동기 모드**를 사용해야 합니다.

| 상황 | 추천 모드 | 이유 |
| :--- | :--- | :--- |
| **단기 작업** (< 3분) | **동기 (Sync)** | 구현이 간단하며, 즉시 결과를 받을 수 있어 효율적입니다. (`run_async=false`) |
| **장기 작업** (> 3분) | **비동기 (Async)** | 클라이언트/네트워크 타임아웃(보통 60~300초)을 회피하기 위해 필수적입니다. |
| **병렬 처리** | **비동기 (Async)** | 여러 에이전트에게 동시에 작업을 시키고 결과를 취합할 때 유용합니다. |
| **불확실성** | **비동기 (Async)** | 작업 시간이 얼마나 걸릴지 예측할 수 없을 때 안전한 선택입니다. |

> **Note:** MCP 클라이언트(Claude Desktop 등)는 일정 시간(약 60초~5분) 동안 응답이 없으면 연결을 강제로 끊습니다. 따라서 복잡한 코딩이나 심층 분석 작업은 반드시 비동기 모드를 사용해야 안전합니다.

## 4. 새로운 API 명세 (Tools)

### 4.1 `use_agent`

긴 작업을 시작하고 즉시 `task_id`를 반환합니다.

-   **Input Schema:**
    -   기존 `use_agent`의 모든 파라미터 (`cli_name`, `message`, `system_prompt`, `args`, `timeout` 등)를 동일하게 사용합니다.
    -   `run_async`: `true`로 설정 시 비동기 모드로 동작합니다.
-   **Output Schema (즉시 반환):**
    ```json
    {
      "task_id": "<unique-task-identifier>",
      "status": "running",
      "message": "Task started asynchronously"
    }
    ```

### 4.2 `get_task_status`

`task_id`를 사용하여 작업의 현재 상태와 결과(완료 시)를 조회합니다.

-   **Input Schema:**
    ```json
    {
      "task_id": {
        "type": "string",
        "description": "use_agent로부터 받은 작업 ID"
      },
      "timeout": {
        "type": "number",
        "description": "상태가 running일 경우 대기할 최대 시간 (초). 설정 시 Long Polling으로 동작하여 폴링 횟수를 줄일 수 있습니다. (권장: 30)",
        "default": 0
      }
    }
    ```
-   **Output Schema:**
    -   **작업 진행 중:**
        ```json
        {
          "status": "running",
          "elapsed_time": 120 // (초 단위 경과 시간)
        }
        ```
    -   **작업 완료:**
        ```json
        {
          "status": "completed",
          "result": "<CLI 실행 결과 문자열>"
        }
        ```
    -   **작업 실패:**
        ```json
        {
          "status": "failed",
          "error": "<에러 메시지>"
        }
        ```
    -   **작업을 찾을 수 없음:**
        ```json
        {
          "status": "not_found",
          "error": "Task ID not found or expired."
        }
        ```

## 5. 단계별 구현 전략

### 1단계: MVP (최소 기능 제품)

빠른 가치 검증을 위해 핵심 기능에 집중합니다.

1.  **Task Manager 구현:**
    -   서버 내부에 작업 상태를 관리할 `TaskManager` 클래스를 구현합니다.
    -   저장소(Storage)를 교체할 수 있도록, 저장소 로직을 분리한 **인터페이스 기반으로 설계**합니다. (`Strategy Pattern`)
2.  **In-Memory Storage 구현:**
    -   작업 상태를 Python `dict`를 사용하여 메모리에 저장하는 `InMemoryStorage` 클래스를 구현하여 `TaskManager`에 주입합니다.
3.  **리소스 관리:**
    -   메모리 누수를 방지하기 위해, 완료/실패된 작업은 **1시간 후 자동으로 삭제**되는 TTL(Time-To-Live) 기반의 간단한 쓰레기 수집(Garbage Collection) 로직을 필수로 구현합니다.
4.  **한계점 명시:**
    -   이 단계의 명백한 한계점은 **"서버 재시작 시 모든 작업 내역이 유실된다"**는 것입니다. 이 내용은 문서와 로그에 명확히 기록합니다.

### 2단계: 견고성 강화

MVP의 기능이 검증된 후, 시스템의 안정성을 높입니다.

1.  **SQLite Storage 구현:**
    -   1단계에서 정의한 저장소 인터페이스를 따르는 `SqliteStorage` 클래스를 구현합니다. Python에 내장된 `sqlite3` 모듈을 사용하여 외부 의존성 없이 영속성을 확보합니다.
2.  **저장소 교체:**
    -   서버 시작 시 `TaskManager`에 `InMemoryStorage` 대신 `SqliteStorage`를 주입합니다. 설계가 잘 되어있다면 이 교체 작업은 매우 간단합니다.
3.  **재시작 복구 로직:**
    -   서버가 재시작될 때, `SqliteStorage`는 DB에 'running' 상태로 남아있던 모든 작업을 'failed' (사유: "Server restarted") 상태로 변경하는 복구 로지을 구현하여 클라이언트가 작업의 비정상 종료를 인지할 수 있게 합니다.

---
이 문서는 새로운 비동기 작업 처리 기능의 설계와 구현 계획을 정의합니다.
